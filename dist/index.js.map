{"version":3,"file":"index.js","sources":["../webpack://action-internal-link-consistency/./node_modules/@actions/core/lib/command.js","../webpack://action-internal-link-consistency/./node_modules/@actions/core/lib/core.js","../webpack://action-internal-link-consistency/./node_modules/@actions/core/lib/file-command.js","../webpack://action-internal-link-consistency/./node_modules/@actions/core/lib/utils.js","../webpack://action-internal-link-consistency/external \"fs\"","../webpack://action-internal-link-consistency/external \"os\"","../webpack://action-internal-link-consistency/external \"path\"","../webpack://action-internal-link-consistency/webpack/bootstrap","../webpack://action-internal-link-consistency/webpack/runtime/make namespace object","../webpack://action-internal-link-consistency/webpack/runtime/compat","../webpack://action-internal-link-consistency/./src/FileDetails.ts","../webpack://action-internal-link-consistency/./src/SupportedFormats.ts","../webpack://action-internal-link-consistency/./src/Config.ts","../webpack://action-internal-link-consistency/./src/Defaults.ts","../webpack://action-internal-link-consistency/./src/InputParser.ts","../webpack://action-internal-link-consistency/./src/Setup.ts","../webpack://action-internal-link-consistency/./src/InclusionController.ts","../webpack://action-internal-link-consistency/./src/DataCollection/SourceData.ts","../webpack://action-internal-link-consistency/./src/IoOperations.ts","../webpack://action-internal-link-consistency/./src/DataCollection/TargetData.ts","../webpack://action-internal-link-consistency/./src/CrossReferencer.ts","../webpack://action-internal-link-consistency/./src/IssueLogger.ts","../webpack://action-internal-link-consistency/./src/Main.ts"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n */\nfunction error(message) {\n    command_1.issue('error', message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds an warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n */\nfunction warning(message) {\n    command_1.issue('warning', message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n//# sourceMappingURL=utils.js.map","module.exports = require(\"fs\");;","module.exports = require(\"os\");;","module.exports = require(\"path\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","import { parse, ParsedPath } from 'path';\nimport { IFileDetails } from './Interfaces';\n\nexport class FileDetails implements IFileDetails {\n    public FullPath: string;\n    public Dir: string;\n    public Base: string;\n    public Name: string;\n    public Ext: string;\n    public Root: string;\n\n    public constructor(path: string) {\n        const result: ParsedPath = parse(path);\n\n        this.FullPath = path;\n        this.Root = result.root;\n        this.Dir = result.dir;\n        this.Base = result.base;\n        this.Name = result.name;\n        this.Ext = result.ext;\n    }\n}\n","import { ISupportedFormat } from './Interfaces';\n\nexport const SupportedFormats: ISupportedFormat[] = [\n    {\n        Ext: '.md',\n        Pattern: /^(?!<!--).*\\[[^[]+\\]\\(([^)]+)\\)/gm\n    },\n    {\n        Ext: '.toml',\n        Pattern: /^(?!#).*path\\s=\\s\"(.*)\"$/gm\n    }\n];\n","import { existsSync } from 'fs';\nimport { isAbsolute, normalize } from 'path';\nimport { FileDetails } from './FileDetails';\nimport { ITarget, IFileDetails, ISupportedFormat } from './Interfaces';\nimport { SupportedFormats } from './SupportedFormats';\n\nexport class Config {\n    public Source: string;\n    public Targets: ITarget[];\n\n    public FileTypes: string[];\n    public SupportedFormats: ISupportedFormat[];\n\n    public ExcludeFolders: string[];\n    public ExcludeFiles: string[];\n\n    public constructor(source: string, targets: string[], fileTypes?: string[], excludeFolders?: string[], excludeFiles?: string[]) {\n        this.SupportedFormats = SupportedFormats;\n\n        // SOURCE\n        if (this.IsValidRelativePath(source)) {\n            const normalizedSource = normalize(source);\n            this.Source = normalizedSource;\n        } else {\n            throw new Error(`[Config]: Source path not valid: ${source}`);\n        }\n\n        // TARGETS\n        this.Targets = [];\n        for (const targetPath of targets) {\n            const normalizedPath = normalize(targetPath);\n            if (this.IsValidRelativePath(normalizedPath)) {\n                const targetDetails: IFileDetails = new FileDetails(normalizedPath);\n                const patternData: ISupportedFormat | undefined = this.SupportedFormats.find(e => e.Ext === targetDetails.Ext);\n\n                if (patternData === undefined) {\n                    throw new Error(`[Config]: Target must be a supported document type: \\n Current: ${targetDetails.Ext} | Supported: ${this.SupportedFormats.map(e => e.Ext)}`);\n                }\n                this.Targets.push({\n                    FullPath: targetDetails.FullPath,\n                    Dir: targetDetails.Dir,\n                    Base: targetDetails.Base,\n                    Name: targetDetails.Name,\n                    Ext: targetDetails.Ext,\n                    Root: targetDetails.Root,\n                    Pattern: patternData.Pattern\n                });\n            } else {\n                throw new Error(`[Config]: Target path not valid: ${targetPath}`);\n            }\n        }\n\n        // FILE TYPES\n        this.FileTypes = [];\n        if (fileTypes !== undefined) {\n            for (const fileType of fileTypes) {\n                if (fileType === '') {\n                    throw new Error(`[Config]: Can't have an empty string as extension`);\n                } else {\n                    this.FileTypes.push(fileType);\n                }\n            }\n        }\n\n        this.ExcludeFolders = [];\n        if (excludeFolders !== undefined) {\n            for (const excludeFolder of excludeFolders) {\n                if (excludeFolder === '') {\n                    throw new Error(`[Config]: Can't have an empty exclude folder`);\n                }\n                const normalizedFolderPath = normalize(excludeFolder);\n\n                if (isAbsolute(normalizedFolderPath)) {\n                    throw new Error(`[Config]: ExcludeFolder is not a valid relative path: ${normalizedFolderPath}`);\n                } else {\n                    this.ExcludeFolders.push(normalizedFolderPath);\n                }\n            }\n        }\n\n        this.ExcludeFiles = [];\n        if (excludeFiles !== undefined) {\n            for (const excludeFile of excludeFiles) {\n                if (excludeFile === '') {\n                    throw new Error(`[Config]: Can't have an empty exclude file`);\n                }\n                const normalizedFile = normalize(excludeFile);\n                if (isAbsolute(normalizedFile)) {\n                    throw new Error(`[Config]: ExcludeFile is not a valid relative path: ${normalizedFile}`);\n                } else {\n                    this.ExcludeFiles.push(normalizedFile);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the config in a prettified readable string.\n     */\n    public ToString(): string {\n        let output = '';\n        output += `\\tSource: ${this.Source}\\n`;\n        output += `\\tFileTypes: ${this.FileTypes}\\n`;\n        output += `\\tExcludeFolders: ${this.ExcludeFolders}\\n`;\n        output += `\\tExcludeFiles: ${this.ExcludeFiles}\\n`;\n        for (const target of this.Targets) {\n            output += `\\tTarget: ${target.FullPath} | Ext: ${target.Ext}\\n`;\n        }\n        return output;\n    }\n\n    private IsValidRelativePath(path: string): boolean {\n        if (isAbsolute(path)) {\n            throw new Error(`[Config]: Path must be relative: ${path}`);\n        }\n\n        if (!existsSync(path)) {\n            throw new Error(`[Config]: Path does not exist: ${path}`);\n        }\n        return true;\n    }\n}\n","export const defaultSource = './__tests__/data/source_data/';\nexport const defaultFileTypes = ['.test'];\nexport const defaultExcludeFiles = ['./__tests__/data/source_data/should_be_ignored.test'];\nexport const defaultExcludeFolders = ['./__tests__/data/source_data/ignorefolder'];\nexport const defaultTargets = ['./__tests__/data/ValidToml.toml', './__tests__/data/ValidReadme.md'];\n","import * as core from '@actions/core';\n\nexport function ParseInput(inputName: string): string | undefined {\n    const input = core.getInput(inputName);\n    if (input === undefined || input === '') {\n        // core.setFailed(`Config Error: Unable to get array input ${inputName}`);\n        // console.log(`Config Error: Unable to get config input ${inputName}`); // Using defaults\n        return undefined;\n    } else {\n        return input;\n    }\n}\n\nexport function ParseInputArray(inputName: string): string[] | undefined {\n    let result: string[];\n    const input = ParseInput(inputName);\n    if (input === undefined) return undefined;\n    try {\n        result = JSON.parse(input);\n        return result;\n    } catch {\n        core.setFailed(`Config Error: Unable to parse array input ${inputName}`);\n        return undefined;\n    }\n}\n\nexport function ParseTargets(inputName: string): string[] | undefined {\n    let result: string[];\n    const input = ParseInput(inputName);\n    if (input === undefined) return undefined;\n    try {\n        result = JSON.parse(input) as string[];\n        return result;\n    } catch {\n        core.setFailed(`Config Error: Unable to parse target array input ${inputName}`);\n        return undefined;\n    }\n}\n","import { Config } from './Config';\nimport { defaultExcludeFiles, defaultExcludeFolders, defaultFileTypes, defaultSource, defaultTargets } from './Defaults';\nimport { ParseInput, ParseInputArray, ParseTargets } from './InputParser';\n\nexport class Setup {\n    public Config: Config;\n\n    public constructor() {\n        // console.log('======= Retrieve inputs =======');\n        const source = ParseInput('source') ?? defaultSource;\n        const fileTypes = ParseInputArray('file-types') ?? defaultFileTypes;\n        const excludeFolders = ParseInputArray('exclude-folders') ?? defaultExcludeFolders;\n        const excludeFiles = ParseInputArray('exclude-files') ?? defaultExcludeFiles;\n\n        const targets: string[] = ParseTargets('targets') ?? defaultTargets;\n\n        this.Config = new Config(source, targets, fileTypes, excludeFolders, excludeFiles);\n    }\n}\n","import { Config } from './Config';\nimport { FileDetails } from './FileDetails';\n\nexport function IncludeFile(fileDetails: FileDetails, config: Config): boolean {\n    return !ExcludeFile(fileDetails.FullPath, config.ExcludeFiles, config.ExcludeFolders) && WhitelistedType(fileDetails.Ext, config.FileTypes);\n}\n\nexport function IncludeFolder(path: string, config: Config): boolean {\n    return !ExcludeDirectory(path, config.ExcludeFolders);\n}\n\nfunction WhitelistedType(extension: string, types: string[]): boolean {\n    if (types.length < 1) return true;\n    return types.some(e => e === extension);\n}\n\nexport function ExcludeFile(filePath: string, excludeFiles: string[], excludeDirs: string[]): boolean {\n    const excludeByDir = excludeDirs.some(dir => filePath.includes(dir));\n    const excludeByFile = excludeFiles.some(e => e === filePath);\n\n    return excludeByDir || excludeByFile;\n}\n\nfunction ExcludeDirectory(dirPath: string, excludeDirs: string[]): boolean {\n    return excludeDirs.some(e => e === dirPath);\n}\n","import { Dirent, readdirSync } from 'fs';\nimport { join } from 'path';\nimport { Config } from '../Config';\nimport { FileDetails } from '../FileDetails';\nimport { IncludeFile, IncludeFolder } from '../InclusionController';\n\nexport class SourceDataCollector {\n    public FileDetails: FileDetails[];\n\n    public constructor(config: Config) {\n        this.FileDetails = this.GetSourceData(config.Source, config);\n    }\n\n    private GetSourceData(path: string, config: Config): FileDetails[] {\n        let files: FileDetails[] = [];\n        const dirs: Dirent[] = readdirSync(path, { withFileTypes: true });\n\n        for (const element of dirs) {\n            const elementPath = join(path, element.name);\n\n            if (element.isDirectory()) {\n                if (IncludeFolder(elementPath, config)) {\n                    files = files.concat(this.GetSourceData(elementPath, config));\n                }\n            } else {\n                const fileDetails = new FileDetails(elementPath);\n                // Only check files that are whitelisted and not excluded\n                if (IncludeFile(fileDetails, config)) {\n                    files.push(fileDetails);\n                }\n            }\n        }\n        return files;\n    }\n}\n","import { readFileSync, existsSync } from 'fs';\n\nexport function IsValidPath(path: string): boolean {\n    return existsSync(path);\n}\n\nexport function ReadFileFromPath(path: string): string {\n    if (!existsSync(path)) throw new Error('Invalid Path');\n    return readFileSync(path, { encoding: 'utf8' });\n}\n","import { join } from 'path';\nimport { Config } from '../Config';\nimport { FileDetails } from '../FileDetails';\nimport { ExcludeFile } from '../InclusionController';\nimport { ITarget, ITargetData, ITargetOutput } from '../Interfaces';\nimport { ReadFileFromPath } from '../IoOperations';\n\nexport class TargetDataCollector {\n    public TargetData: ITargetOutput[];\n\n    public constructor(config: Config) {\n        this.TargetData = [];\n\n        for (const target of config.Targets) {\n            const data = this.GetTargetData(target, config);\n            if (data.length >= 0) {\n                this.TargetData.push({ Target: target.FullPath, Data: data });\n            }\n        }\n    }\n\n    private GetTargetData(target: ITarget, config: Config): ITargetData[] {\n        const output: ITargetData[] = [];\n\n        // Read the contents of the file\n        const content = ReadFileFromPath(target.FullPath);\n        if (content.length <= 0) return [];\n\n        const preProcessor: { Orig: string; Link: string; Target: ITarget; Line: number }[] = [];\n        const matches = content.matchAll(target.Pattern);\n\n        // Scan through the document and parse any links contained therein\n        for (const match of matches) {\n            if (match.index === undefined) {\n                throw new Error('Could not index of match. Something is wrong somewhere');\n            } else {\n                preProcessor.push({ Orig: match[0], Link: match[1], Target: target, Line: GetLineNr(content, match.index) });\n            }\n        }\n\n        // Parse through the links\n        for (const data of preProcessor) {\n            if (this.IgnoreLink(data.Link)) {\n                continue;\n            } else {\n                const rootPath = join(data.Target.Dir, data.Link);\n                if (!ExcludeFile(rootPath, config.ExcludeFiles, config.ExcludeFolders)) {\n                    output.push({\n                        Details: new FileDetails(rootPath),\n                        RelativePath: data.Link,\n                        OriginalMatch: data.Orig,\n                        ParentFile: data.Target,\n                        LineNr: data.Line\n                    });\n                }\n            }\n        }\n        return output;\n    }\n\n    private IgnoreLink(link: string): boolean {\n        return this.WebLink(link) || this.DocLink(link);\n    }\n    private InTargetScope(path: string, scope: string): boolean {\n        return path.includes(scope);\n    }\n\n    private WebLink(link: string): boolean {\n        const webLinks = /^https*:\\/\\//gm;\n        return webLinks.exec(link) !== null;\n    }\n\n    private DocLink(link: string): boolean {\n        const docLink = /^#/gm;\n        return docLink.exec(link) !== null;\n    }\n}\n\nfunction GetLineNr(content: string, charIndex: number): number {\n    const subString = content.substring(0, charIndex);\n    return subString.split('\\n').length;\n}\n","import { FileDetails } from './FileDetails';\nimport { ITargetOutput, IIssueNotInAll } from './Interfaces';\n\nexport class CrossReferencer {\n    // Rules:\n    // File should be present in all targets, or there should be created an issue of the appropriate type:\n\n    // Issue types:\n    // File is missing from one or more targets\n    public MissingFromTargets: IIssueNotInAll[];\n\n    public HasIssues: boolean;\n\n    public constructor(sourceData: FileDetails[], targetData: ITargetOutput[]) {\n        this.MissingFromTargets = [];\n\n        // const clonedSource = [...sourceData];\n        const clonedTarget = [...targetData];\n\n        for (const source of sourceData) {\n            let matchesCount = 0;\n            const missingFromTarget: string[] = [];\n\n            for (const clonedTargetData of clonedTarget) {\n                const match = clonedTargetData.Data.find(e => e.Details.FullPath === source.FullPath);\n                if (match !== undefined) {\n                    // Add to the match count\n                    matchesCount++;\n                    // Remove element from the target data list\n                    clonedTargetData.Data.splice(clonedTargetData.Data.indexOf(match), 1);\n                } else {\n                    missingFromTarget.push(clonedTargetData.Target);\n                }\n            }\n            // If we find that this source was present in all targets, we can remove it from the list\n            if (matchesCount === targetData.length) {\n                // Do nothing, it is present in all targets\n            } else if (matchesCount === 0) {\n                // not present in any targets\n                this.MissingFromTargets.push({ Path: source.FullPath, MissingTargets: targetData.map(e => e.Target) });\n            } else {\n                // File present in some, but not all targets\n                this.MissingFromTargets.push({ Path: source.FullPath, MissingTargets: missingFromTarget });\n            }\n        }\n\n        this.HasIssues = this.MissingFromTargets.length > 0;\n    }\n}\n","import { Config } from './Config';\nimport { IIssueNotInAll } from './Interfaces';\n\nexport class IssueLogger {\n    private SourceIssueOutput: string;\n    public IssueCount: number;\n    private issueIter = 1;\n\n    public constructor(config: Config, sourceIssues: IIssueNotInAll[]) {\n        this.IssueCount = sourceIssues.length;\n        this.SourceIssueOutput = '';\n\n        if (sourceIssues.length > 0) {\n            this.SourceIssueOutput += `Missing links issues:`;\n            for (const issue of sourceIssues) {\n                this.SourceIssueOutput += `\\n${this.GetIssueNumber()} File: ${issue.Path} \\n\\tIs missing from following document(s):`;\n                for (const missingTarget of issue.MissingTargets) {\n                    this.SourceIssueOutput += `\\n\\t\\t${missingTarget}`;\n                }\n                this.SourceIssueOutput += `\\n`;\n            }\n            this.SourceIssueOutput += `\\nTo fix, do one of the following:\\\n                \\n\\t- Add the missing link to the document\\\n                \\n\\t- Remove the file (If no longer valid)\\n`;\n        }\n    }\n\n    public Ouput(): string {\n        let output = `▼ ▼ ▼ ▼ ${this.IssueCount} ${this.IssueCount === 1 ? 'issue' : 'issues'} need to be fixed ▼ ▼ ▼ ▼`;\n        output += `\\n${this.SourceIssueOutput}`;\n        output += `\\nNote: If none of the above fixes are relevant, consider adding the file/folder to this action's ignore-list, but ONLY do so when absolutly necessary.`;\n        output += `\\n▲ ▲ ▲ ▲ End of ${this.IssueCount === 1 ? 'issue' : 'issues'} ▲ ▲ ▲ ▲`;\n        return output;\n    }\n\n    private GetIssueNumber(): string {\n        return `[${this.issueIter++}/${this.IssueCount}] =>`;\n    }\n}\n","// eslint:disable: no-console\nimport * as core from '@actions/core';\n// const github = require('@actions/github');\nimport { Setup } from './Setup';\nimport { FileDetails } from './FileDetails';\nimport { SourceDataCollector } from './DataCollection/SourceData';\nimport { TargetDataCollector } from './DataCollection/TargetData';\nimport { ITargetOutput } from './Interfaces';\nimport { CrossReferencer } from './CrossReferencer';\nimport { IssueLogger } from './IssueLogger';\n\nasync function run(): Promise<void> {\n    try {\n        console.log('======= Running internal link consistency check =======');\n\n        const config = new Setup().Config;\n        console.log(`Running job with config: \\n${config.ToString()}`);\n\n        // console.log('======= Getting source data =======');\n        const sourceData: FileDetails[] = new SourceDataCollector(config).FileDetails;\n        if (sourceData.length <= 0) {\n            core.setFailed('Found no entries in source');\n        }\n\n        // console.log('======= Getting target data =======');\n        const targetData: ITargetOutput[] = new TargetDataCollector(config).TargetData;\n        if (targetData.length <= 0) {\n            core.setFailed('Found no entries in target(s)');\n        }\n\n        // console.log('======= Cross referencing issues =======');\n        const crossChecker = new CrossReferencer(sourceData, targetData);\n        if (crossChecker.HasIssues) {\n            const issues = new IssueLogger(config, crossChecker.MissingFromTargets);\n            core.setFailed('✗ Cross referencing found issues, see output below to fix them');\n            console.error(issues.Ouput());\n        } else {\n            console.log('✓ All checks passes.');\n        }\n    } catch (error) {\n        core.setFailed(error.message);\n    }\n}\n\n// eslint:enable: no-console\nrun();\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACpBA;AACA;A;;;;;ACDA;AACA;A;;;;;ACDA;AACA;A;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;;;;;;;;;;;;;;ACDA;AAGA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AAEA;AAEA;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;;ACLA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AAEA;AAGA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AChBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AC1BA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;;ACVA;AAEA;AACA;AAEA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AC/EA;AAUA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AC9CA;AAKA;AAFA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;;;;;;A","sourceRoot":""}